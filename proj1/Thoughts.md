# Reflecting on Challenges and Committing to Better Practices for Project 2

One of the primary challenges when working with someone else's project is dealing with dependencies. Coordinating and configuring these dependencies to match the repository's requirements was a time-consuming and frustrating task. When we try to run a project just for testing, it really waste lots of time to solve the dependency problems. For example, in the CheapBuy project we are running, because python is the main language, according to common sense, you only need to install the libraries of requirements.txt. But when we tried to install and run it, we discovered many package compatibility issues. For example, the library streamlit has many dependency conflicts. This causes it to take a long time to process the corresponding library with conflicting dependencies. During the process of solving dependency installation, version conflicts and missing packages were common issues that required extensive troubleshooting.

Navigating the unfamiliar codebase was further hindered by insufficient  documentation. While the repository had some documentation, it lacked  the level of detail needed to fully grasp the code's structure, proper  configuration, and component purposes as a beginner. More comprehensive  documentation would significantly aid new developers. For example,  detailing how to handle operational issues, usage of each function, and  startup procedures would provide critical guidance. Additionally, a  high-level architecture diagram summarizing the overall system structure and mapping where specific functionality is implemented would offer  valuable direction. The lack of such documentation led to excessive  trial and error, costing precious time and effort. Expanding the docs to include in-depth operational instructions, functional explanations,  architectural summaries and mapping would equip new developers with the  details needed to efficiently ramp up. Having robust documentation is an investment that pays dividends through accelerated onboarding and  avoided missteps. Underestimating its importance can markedly hamper  development velocity and team cohesion.

Anther challenge we faced was the lack of a frequently asked questions or common issues summary. There were likely many problems, both large and small, that arose during the development process. However, without a summary of these issues and their solutions, we ran into difficulties and had to search extensively online. For example, since we was unfamiliar with web crawlers, I ran into compatibility issues with the webdriver and was unable to get it running. Having a knowledge base documenting common errors and fixes would have saved significant time. I think it would be beneficial for the developers to maintain a FAQ or wiki summarizing any problems encountered and how they were solved. This repository of solutions could help new team members like myself quickly identify and troubleshoot problems without extensive searches. Overall, having organized documentation of past issues can aid other developers work more efficiently and avoid re-solving the same problems.

Reflecting on these challenges, I have identified several practices that could have helped me avoid some of the difficulties associated with running someone else's GitHub code. Here's what I plan to do differently in Project 2:

To alleviate dependency management challenges, WI will establish a dedicated virtual environment for Project 2. A virtual environment is an isolated runtime environment that allows  users to work on a specific project without affecting other projects or  the system's libraries. It acts as an insulated container, ensuring that any changes, installations, or removals of libraries remain confined to that environment. This is particularly beneficial for projects that  might require different versions of the same library. Firstly, we might consider using conda, As a powerful package manager, conda can create, save, load, and switch between environments. Its strength lies in its ability to handle libraries outside of the Python standard library. This ensures that we maintain the correct library versions without affecting system-wide packages or other projects.Using some tools, like conda for Python,  ensure that we have the correct versions without affecting system-wide packages. While conda manages environments and packages, pip is the go-to package installer for Python. In tandem with virtualenv, it creates isolated Python environments. The combination of pip and virtualenv has been a standard approach in the Python community for years. These approaches will simplify dependency management and mitigate version conflicts.

Documentation will be a priority for Project 2. We will commit to documenting my code thoroughly, including comments, clear setup instructions, and explanations of each component's purpose. Recognizing the undeniable correlation between the clarity of documentation and the stability of software, we're committed to leaving no stone unturned in our annotation efforts. Each function, class, and module within the code will come with an elucidative commentary, delineating its purpose, expected inputs, provided outputs, and potential side effects. Such meticulous detailing ensures that each segment of the code is both transparent and comprehensible.Furthermore, to enhance understanding, where relevant, we will embed illustrative code snippets or examples, shedding light on the intended use and application of particular functions or modules. An understanding of the standalone utility of a code piece is vital, but equally important is the comprehension of its symbiotic relationship with other code parts. Hence, our documentation will also underline the interactions and dependencies among various code entities, painting a holistic picture of the entire system.The value of such extensive documentation extends beyond mere comprehension. It fosters stability within the software. When every component's function and behavior are clearly understood, the chances of inadvertent, destabilizing interactions diminish. This clarity not only aids in ensuring consistent modifications but also streamlines the process of unit testing. After all, understanding the expected behavior of a piece of code is half the battle in ensuring its reliability. Moreover, as the software evolves, maintenance and updates become inevitable. In such scenarios, a well-documented codebase serves as an invaluable roadmap. It guides developers through the intricacies of the software, enabling them to pinpoint where changes are needed, all while mitigating the risks of inadvertently introducing new bugs or conflicts.


